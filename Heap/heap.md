# Пирамиды

Пирамида (англ. heap) представляет собой ослабленную версию двоичного
дерева. Все слои кучи за исключением последнего должны быть заполнены
полностью, заполнение последнего слоя происходит слева направо.

- Реализуется  на основе массива;
- Значение ключа родителя всегда больше ключа любого из потомков;
- Нет упорядоченности левого и правого ключей.

Собственно говоря, куча является достаточно хаотичной структурой данных.
Поиск ключа происходит за время O(N), поскольку никакой упоряоченности
нет, приходится линейно сканировать весь массив целиком. Куча обладает
другими преимуществами:

- Удаление самого большого ключа происходит быстро. За О(log N),
  поскольку он всегда находится на первом месте в массиве. Правда, потом
  ему надо найти приемника;
- Также имеется возможность быстрой вставки новых элементов за О(log N).

Пирамиды (кучи) используются для реализации приоритетных очередей, когда
надо максимально быстро обслужить объект с максимальным приоритетом, а
также учитывать и ранжировать все поступающие объекты.

## Удаление корневого узла

Само по себе удаление выполняется очень просто. Необходимо удалить
значение из массива по индексу [0], другое дело, что после удаление нужно
какое- то значение в этот индекс поместить:

1) Последний значимый элемент в массиве перемещаем на первое место
   (помещаем в корень кучи);
2) Определяем максимальный элемент среди дочерних (I * 2 + 1 и I * 2 +
   2. Где I - это индекс родительского узла в массиве), если
   максимальное значение ключа больше родительского- меняем местами этот
   дочерний и родительский узлы. Продолжаем таким образом перемещать
   узел вниз по дереву до тех пор, пока его ключ не окажется больше
   ключа дочерних узлов.

## Вставка

Новый элемент помещается в первое свободное место в массиве (в конец).

- Если ключ нового элемента больше ключа родителя- меняем их местами
  (если I - индекс нового элемента, то индекс его родительского узла
  вычисляется по формуле (I - 1) // 2).
- Если ключ нового элемента меньше ключа родителя- проверяем, больше ли
  он, чем ключи дочерних элементов. Вот тут надо подумать побольше,
  потому что если входные элементы не повторяются, то такой ситуации и
  не возникнет;
- Производим просеивание вверх, а затем просеивание вниз до тех пор,
  пока ключ родителя не будет больше, а ключи дочерних меньше.

## Просеивание вниз и вверх

Просеивание вверх занимается перемещением некого узла с конкретным
значением вверх по дереву до тех пор, пока его ключ не окажется меньше
родительского.
> Алгоритм сравнивает значение ключа двигаемого узла и ключ родителя.
> Если ключ ключ родителя меньше ключа двигаемого узла- они меняются
> местами.

Просеивание вниз занимается перемещением узла вниз по дереву до тех пор,
пока либо его ключ не окажется больше ключей дочерних узлов либо у него
не окажется потомков.
> Алгоритм сравнивает значение ключа родителя и максимального из ключей
> ближайших потомков. Если ключ потомка больше ключа родителя- они с
> родителем меняются местами в массиве.

## Что происходит при попытке добавить узел с ключом, который уже присутствует в дереве?

Например в кучу [100, 50, 75, 12, 13] отлично добавится элемент с ключом
12 и никто и носом не поведет.

А вот при попытке построить кучу из [1, 1, 1, 1] могут возникнуть
проблемы. Алгоритм просеивания вверх будет искать такую ситуацию, при
которой родительский ключ будет строго больше ключа нового элемента. Но
такой ситуации не наступит.

Исходя из строгого определения кучи из урока, а именно: "ключ родителя
строго больше любого из ключей потомков", я считаю, что если при
выполненнии просеивания вверх получлиось так, что ключи нового узла и
родителя совпали- необходимо переходить к просеиванию вниз.
